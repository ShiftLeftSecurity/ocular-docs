# Finding previously unknown vulnerabilities by example (CVE-2018-20157)

This tutorial is about finding an XXE in [OpenRefine](https://github.com/OpenRefine/OpenRefine/). OpenRefine is an system [todo]

## Creating the CPG
OpenRefine does not come packaged into a single executable jar or war file as expected by `java2cpg`. Luckily, `java2cpg` is rather forgiving when it comes to JAR file structure: a zip file named "jar" containing the class files of interest is perfectly sufficient. We build this file as follows.

```
wget https://github.com/OpenRefine/OpenRefine/releases/download/3.1/openrefine-linux-3.1.tar.gz
tar xfz openrefine-linux-3.1.tar.gz
find openrefine-3.1 -name "*.class" | zip openrefine.jar -@
```
We then run `java2cpg`, specifying that we wish to include the application code from the namespaces `com.google.refine` and `org.openrefine` for this CPG.

```
./java2cpg.sh openrefine.jar -w com.google.refine,org.openrefine -nb -o openrefine.bin.zip
```

Finally, we load the newly created CPG into ocular

```
./ocular.sh
ocular> loadCpg("openrefine.bin.zip")
```

## Peering inside the application aka. is it vulnerable?

XXE is strongly related to XML parser, thus we need to find some calls to them. First let's look if we find anything usefull containing XML. 

```
ocular> cpg.method.fullName(".*XML.*").fullName.toList.sorted
res50: List[String] = List(
  "com.google.refine.importers.XmlImporter.access$100:javax.xml.stream.XMLStreamReader(java.io.InputStream)",
  "com.google.refine.importers.XmlImporter.createXMLStreamReader:javax.xml.stream.XMLStreamReader(java.io.InputStream)",
  "com.google.refine.importers.XmlImporter.descendElement:org.json.JSONObject(javax.xml.stream.XMLStreamReader,com.google.refine.importers.XmlImporter$PreviewParsingState)",
  "javax.xml.stream.XMLInputFactory.createXMLStreamReader:javax.xml.stream.XMLStreamReader(java.io.InputStream)",
  "javax.xml.stream.XMLInputFactory.newInstance:javax.xml.stream.XMLInputFactory()",
  "javax.xml.stream.XMLInputFactory.setProperty:void(java.lang.String,java.lang.Object)",
  "javax.xml.stream.XMLStreamException.<init>:void(java.lang.String)",
  "javax.xml.stream.XMLStreamReader.getAttributeCount:int()",
  "javax.xml.stream.XMLStreamReader.getAttributeLocalName:java.lang.String(int)",
  "javax.xml.stream.XMLStreamReader.getAttributePrefix:java.lang.String(int)",
  "javax.xml.stream.XMLStreamReader.getAttributeValue:java.lang.String(int)",
  "javax.xml.stream.XMLStreamReader.getEventType:int()",
  "javax.xml.stream.XMLStreamReader.getLocalName:java.lang.String()",
  "javax.xml.stream.XMLStreamReader.getNamespaceCount:int()",
  "javax.xml.stream.XMLStreamReader.getNamespacePrefix:java.lang.String(int)",
  "javax.xml.stream.XMLStreamReader.getNamespaceURI:java.lang.String()",
  "javax.xml.stream.XMLStreamReader.getNamespaceURI:java.lang.String(int)",
  "javax.xml.stream.XMLStreamReader.getPrefix:java.lang.String()",
  "javax.xml.stream.XMLStreamReader.getText:java.lang.String()",
  "javax.xml.stream.XMLStreamReader.hasNext:boolean()",
  "javax.xml.stream.XMLStreamReader.next:int()",
  "org.apache.poi.POIXMLDocument.hasOOXMLHeader:boolean(java.io.InputStream)"
)
```

Not many methods but still to much noise for us. We can slice it down a bit.
```
ocular> cpg.method.fullName(".*XML.*").fullNameNot("(com.google|.*.(get|next|set|has)).*").fullName.toList.sorted
res57: List[String] = List(
  "javax.xml.stream.XMLInputFactory.createXMLStreamReader:javax.xml.stream.XMLStreamReader(java.io.InputStream)",
  "javax.xml.stream.XMLInputFactory.newInstance:javax.xml.stream.XMLInputFactory()",
  "javax.xml.stream.XMLStreamException.<init>:void(java.lang.String)"
)
```

Now it is is clear that we have to look for `XMLStreamReader`. [XMLStreamReader](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet#XMLInputFactory_.28a_StAX_parser.29) is one of the may vulnerable Java [XML parsing libraries](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet). With the countermessuares listed on the prevention cheat sheet page of OWASP, we know what we need to look for!

We need to be sure that these settings are not set: 
```
xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // This disables DTDs entirely for that factory
xmlInputFactory.setProperty("javax.xml.stream.isSupportingExternalEntities", false); // disable external entities
```

And we are lucky, the application only sets `isReplacingEntityReferences` and `isCoalescing`. Both methods are not mentioned in the cheat sheet and according to the [documetnation](https://docs.oracle.com/javase/8/docs/api/javax/xml/stream/XMLInputFactory.html), they are not interfering the DTD import.  
```
ocular> cpg.method.name("setProperty").fullName(".*XML.*").parameter.argument.literal.name.p
res79: List[String] = List("\"javax.xml.stream.isReplacingEntityReferences\"", "\"javax.xml.stream.isCoalescing\"")
```

With only two queries we know that the application is vulnerable!

## Identifying importers (sources)

We start looking for imports by looking for all methods that contain the substring "Import" in their method name. This search yields 502 methods, and is thus still a bit too generic.

```
ocular>  cpg.method.fullName(".*Import.*").toList.size
res1: Int = 502
```

We narrow in on importers that we can access via HTTP by making use of a naming convention often found in [Java Servlet](https://en.wikipedia.org/wiki/Servlet) code: often HTTP Get handlers are named `doGet`, while HTTP POST handlers are named `doPost`. By executing the query below, the number of results is decreased to 13 methods, which we can easily review manually.

```
ocular> cpg.method.fullName(".*Import.*do(Get|Post).*").toList.size
res2: Int = 13
```

Some methods are stored in an interesting class with the name `DefaultImportingController`. We enhance our query by replacing `Import` with `DefaultImportingController`. The result consists, not surprisingly, of a `doGet` and a `doPost` method.
```
cpg.method.fullName(".*DefaultImportingController.*do(Get|Post).*").fullName.p

com.google.refine.importing.DefaultImportingController.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
com.google.refine.importing.DefaultImportingController.doPost:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
```

Looks like we found a interesting source and only used three queries! 

While we found the method we still need to create a source for the data flow. The query below defines a source and reduces the number of starting points to `HttpServletRequest` parameter of the variables. Sometimes the `HttpServletResponse` is also interesting but as we mentioned earlier, we start with the low hanging fruits. 

```
ocular> val source = cpg.method.fullName(".*DefaultImportingController.*do(Get|Post).*").parameter.evalType(".*HttpServletRequest.*")
```

Alright, we are done in this section and have a nice source and a good starting point.

## Looking for the sink


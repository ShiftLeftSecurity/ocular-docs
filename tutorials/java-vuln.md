# Java Vulnerable Lab

This is an alternative "Getting-started" guide based on the popular
Java project "Java Vulnerable Lab", a benchmarking application for
vulnerability discovery tools.


This tutorial walks you through the core features of the ShiftLeft
Command Line Tools. The tutorial demonstrates how the tooling can be
used to:

- automatically scan programs for vulnerabilities
- interactively query the code property graph to uncover attack surface
- formulate ad-hoc queries to identify vulnerabilities
- customize the scanner's detection rules
- automatically scan and generate a report via non-interactive scripts


The philosophy behind our tooling is that, while creating a
"one-fits-all" vulnerability scanner borders on the impossible, you
can certainly provide the tooling that vulnerability researchers
require to explore code bases in order to determine vulnerability
patterns, formulate these patterns in concise and expressive
languages, and persist them, such that code can be automatically
scanned for these patterns in the future. Instead of only showcasing
the tooling's default capabilities, in this tutorial we also
demonstrate the many ways in which the tooling can be adapted and
extended to suit your specific needs.

## Prerequisites

Install the ShiftLeft Command Line Tools into local directory
$shiftleft as described in the installation documentation.

## Running example

This tutorial is based on the sample application "JavaVulnerableLab"
which you can find at github
( https://github.com/CSPF-Founder/JavaVulnerableLab ). We have included
the project's WAR file for convenience.

JavaVulnerableLab is a is a classic java web application using JSP and
servlets. It comes with different sample vulnerabilities, including
typical injection vulnerabilities like sql injection. Throughout this
guide, we focus on a sql injection vulnerability in the
"EmailCheck.java" that can be found in the listing below. While this
controller consumes also POST requests we will focus on the GET
request that ends up in a sql query, see the snippet below.

```
protected void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType("application/json");
    PrintWriter out = response.getWriter();
    try {
           Connection con=new DBConnect().connect(getServletContext().getRealPath("/WEB-INF/config.properties"));
           String email=request.getParameter("email").trim();
           JSONObject json=new JSONObject();
            if(con!=null && !con.isClosed())
            {
                ResultSet rs=null;
                Statement stmt = con.createStatement();  
                rs=stmt.executeQuery("select * from users where email='"+email+"'");
            [...]
}

@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    processRequest(request, response);
}
```

We are interested in the variable `request` which is of type
`HttpServletRequest` and is part of the `doGet` signature. As we can
see, the object is passed to `processRequest` where the parameter
`email` is read as a string from it. The variable is concatenated to
the sql query without prior checks. This leads to an SQL injection. We
now illustrate how this vulnerability is identified using
Ocular.

### Generating Code Property Graphs and Security Profiles

Please begin by downloading thee WAR file from GitHub. The code
property graph can then be created as follows:

```
cd $shiftleft
./java2cpg.sh subjects/JavaVulnerableLab.war -o cpg.bin.zip
```

This command creates a file named `cpg.bin.zip` containing the code
property graph in a binary format.

The CPG can be automatically analyzed using the cpg2sp tool to
determine potentially vulnerable flows and summarize them in a
security profile:

```
./cpg2sp.sh --cpg ./cpg.bin.zip -o javavulnerablelab.sp
```

This command creates a file named `javavulnerablelab.sp` containing
the security profile from the CPG in cpg.bin.zip. The security profile
is generated by evaluating the security policy in ~/.shiftleft/policy/
against the CPG.

(For additional output formats, refer to the java2cpg and cpg2sp
documentation, respectively).

## Generating an Initial Scan Report

The ShiftLeft Command Line Tools let you query code property graphs
and security profiles, interactively and
non-interactively. As an example for non-interactive querying,
consider the script in `scripts/report.sc`:

```
@main def exec(spFilename: String, outFilename: String) = {
  loadSp(spFilename)
  sp.findings.sortedByScore.l |> outFilename
}
```

This script loads the security profile at `spFilename`, and evaluates
the expression `sp.findings.sortedByScore.l` to obtain a list of
findings sorted by score. The list is piped to the file `outFilename`
via the `|>` operator.

You can run this script as follows:
```
./ocular.sh --script scripts/report.sc --params spFilename=javavulnerablelab.sp,outFilename=report.txt
```

As a result, the text file `report.txt` is generated, which contains
all findings in a human-readable format. Let's take a look at one the
the findings to get an idea of the type of information the report
contains:

```
Title: http-to-sql
Score: 9.0
Categories: [a1-injection]
Flow ids: [1715]
Description: Attacker controlled data is used in a SQL query without undergoing escaping or validation. This could allow an attacker to read sensitive dat a from the database or modify its content.See http://cwe.mitre.org/data/definitions/89.html
-------------------------------------
Flow 0:
IO Tags: Set(http) -> Set(sql)
Data Tags: Set(DATA_TYPE: pii, DATA_TYPE: contact, DATA_LANGUAGE: SQL)
routes: 
trigger methods:
org.cysecurity.cspf.jvl.controller.EmailCheck.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
org.cysecurity.cspf.jvl.controller.EmailCheck.doPost:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)

Primary flow:
 ____________________________________________________________________________________________________________________________________________________________________________________________________________________
 | param     | type                                 | method        | signature                                                                                                                                      |
 |===================================================================================================================================================================================================================|
 | request(1)| javax.servlet.http.HttpServletRequest| doGet         | org.cysecurity.cspf.jvl.controller.EmailCheck.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)         |
 | request(1)| javax.servlet.http.HttpServletRequest| processRequest| org.cysecurity.cspf.jvl.controller.EmailCheck.processRequest:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)|
 | this(0)   | javax.servlet.http.HttpServletRequest| getParameter  | javax.servlet.http.HttpServletRequest.getParameter:java.lang.String(java.lang.String)                                                          |
 | return(-1)| java.lang.String                     | getParameter  | javax.servlet.http.HttpServletRequest.getParameter:java.lang.String(java.lang.String)                                                          |
 | this(0)   | java.lang.String                     | trim          | java.lang.String.trim:java.lang.String()                                                                                                       |
 | return(-1)| java.lang.String                     | trim          | java.lang.String.trim:java.lang.String()                                                                                                       |
 | email     | java.lang.String                     | processRequest| org.cysecurity.cspf.jvl.controller.EmailCheck.processRequest:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)|
 | param0(1) | java.lang.String                     | append        | java.lang.StringBuilder.append:java.lang.StringBuilder(java.lang.String)                                                                       |
 | return(-1)| java.lang.StringBuilder              | append        | java.lang.StringBuilder.append:java.lang.StringBuilder(java.lang.String)                                                                       |
 | this(0)   | java.lang.StringBuilder              | append        | java.lang.StringBuilder.append:java.lang.StringBuilder(java.lang.String)                                                                       |
 | return(-1)| java.lang.StringBuilder              | append        | java.lang.StringBuilder.append:java.lang.StringBuilder(java.lang.String)                                                                       |
 | this(0)   | java.lang.StringBuilder              | toString      | java.lang.StringBuilder.toString:java.lang.String()                                                                                            |
 | return(-1)| java.lang.String                     | toString      | java.lang.StringBuilder.toString:java.lang.String()                                                                                            |
 | param0(1) | java.lang.String                     | executeQuery  | java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)                                                                           |
```
 
 
Along with other findings, we see an SQL injection vulnerability
triggerable via HTTP with a score of 9.0. Findings are scored in order
to allow for filtering. Findings also include a human-readable
description that further characterizes the potential vulnerability, as
well as the information flows associated with the vulnerability.

In this example, a single information flow is associated with the
vulnerability. The Ocular analyzer identifies that the parameter
`request` of the method `doGet` is attacker-controlled with high
probability as it is an HTTP request parameter. Tracking the flow of
`request`, the variable is passed into the method `processRequest`
where it is Base64-decoded and used in the initialization of a
`ByteArrayInputStream`. This input stream is itself used to initialize
an `ObjectInputStream`. Lastly, the `readObject` method is invoked on the
tainted input stream, resulting in the deserialization of
attacker-controlled data. The flow description additionally provides
HTTP input routes when possible (`/admin/login` in this case), and
externally triggerable methods to invoke the vulnerable flow
(`doPostLogin` in this example).

## Interactively exploring and filtering security profiles

Security profiles can be explored interactively on Ocular, using a
domain specific language. Ocular can be started as follows:

```
 ./ocular.sh

 Welcome to the cpg console :)
 Commands:
 helpMsg                         // prints this help dialog
 status                          // prints the current status
 loadCpg("path/to/file.[xml|gryo|bin.zip]") // loads cpg (format inferred from suffix)
 loadSp("path/to/file.[sp]")                // loads sp
 ...

 Ocular status:
 No CPG currently loaded.
 CPG can be loaded via a `loadCpg` command. See `help`.
 Welcome to the Ocular - what would you like to query today? ;)
 ocular>
```
 
As demonstrated in the non-interactive script report.sc, we can load
the security profile "javavulnerablelab.sp" by issuing the command:
```
loadSp("javavulnerablelab.sp")
```

This creates an object named `sp` that provides access to the security
profile. Ocular offers tab-completion to facilitate learning of the
domain specific query language. For example, you can enter

```
 sp.findings.<TAB>
 !=             category       equals         getClass       isInstanceOf   raw            scoreAtMost    spTestsFlows   |>
 ==             dedup          filter         hashCode       l              score          size           title
 asInstanceOf   description    flatMap        ioFlows        map            scoreAtLeast   sortedByScore  toString
```

to obtain a list of possible operations that can be executed on
findings. In particular, findings support the `scoreAtLeast` method,
which allows findings to be filtered such that only findings scored
above or equal to a threshold are returned. For example,

```
sp.findings.scoreAtLeast(8).l.size
```

returns only findings with a score of at least 8. Please note that the
query language is lazily evaluated, that is,
`sp.findings.scoreAtLeast(8)` only yields in an expression, and it is
only evaluated as it is converted to a list via the `l` directive (a
shorthand for "toList").

All string properties support regular expressions. For example, you
can obtain all findings related to serialization as follows:
```
sp.findings.title(".*serialize.*").l
```

All lists support the functional combinators of the Scala language.
Moreover, we provide the functional combinators `filter`, `map`, and
`flatMap` directly for expression of the DSL. For example, instead of
using the builting method `scoreAtLeast`, the same effect can be
achieved via a filter operation: 

```
sp.findings.filter(_.score >= 8).size
```

This allows more complex filtering rules to be expressed via lambdas.
For example,

```
sp.findings.filter(x =>  x.score >=8 && x.categories.contains("a1-injection")).l
```

returns only the findings with a score greater or equal to 8, where
the finding's categories includes "a1-injection".


## Uncovering attack surface with the code property graph

The code property graph contains information about the processed code
on different levels of abstraction, from dependencies, to type
hierarchies, control flow, data flow, and instruction-level
information. Like the SP, the CPG can be queried interactively via Ocular or via non-interactive scripts. We now illustrate interactive
querying, however, all queries can also be used as-in in interactive
scripts. 

The CPG is loaded via the `loadCpg` command:

```
loadCpg("cpg.bin.zip")
```

This creates an object named cpg, which provides access to the code
property graph. We begin by exploring the program dependencies: 

```
cpg.dependency.name.l
```

This provides a list of all dependency names. We support functional
combinators. For example, to output (name, version) pairs, we can use
the following expression: 

```
cpg.dependency.map(x => (x.name, x.version)).l
```
which yields

```
cpg.dependency.map(x => (x.name, x.version)).l 
res2: List[(String, String)] = List(
  ("junit", "3.8.1"),
  ("json", "20090211"),
  ("servlet-api", "2.3"),
  ("jstl", "1.2"),
  ("hibernate-core", "4.0.1.Final"),
  ("mysql-connector-java", "5.1.26"),
  ("hibernate-core", "4.0.1.Final"),
  ("commons-collections", "3.2.1"),
  ("hibernate-commons-annotations", "4.0.1.Final"),
  ("xml-apis", "1.0.b2"),
  ("jstl", "1.2"),
  ("dom4j", "1.6.1"),
  ("jboss-logging", "3.1.0.CR2"),
  ("jboss-transaction-api_1.1_spec", "1.0.0.Final"),
  ("antlr", "2.7.7"),
  ("hibernate-jpa", "2.0-api-1.0.1.Final"),
  ("javassist", "3.15.0-GA"),
  ("json", "20090211")
)

```

It is also possible to process CPG sub graphs via external programs by
exporting them to JSON. For example,

```
cpg.dependency.toJson |> "/tmp/dependencies.json"
```

dumps dependency information into the file "/tmp/dependencies.json" is
JSON format. Fields of the CPG can be queried using regular
expressions. For example, to determine whether an application uses the
servlet api, a quick query could be

```
cpg.dependency.name(".*servlet.*").l.nonEmpty 
res9: Boolean = true
```

The `servlet-api` indicates that we have should look for methods with
a `HttpServletRequest` type as parameter. This can be done with this
query

```
cpg.method.parameter.evalType(".*HttpServletRequest.*").method.fullName.p 
[...]
org.cysecurity.cspf.jvl.controller.EmailCheck.processRequest:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
org.cysecurity.cspf.jvl.controller.EmailCheck.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
org.cysecurity.cspf.jvl.controller.EmailCheck.doPost:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
[..]
```

And we find our methods from the introduction. From here on we already
have our first source

```
val source = cpg.method.fullName(".*EmailCheck.*").parameter 
```

With this query we, definded every parameter, of methods which
signaturenames matching `.*EmailCheck.*`, as source. The next step is
to define our sinks. Let's assume that we don't know anything about
our target and we just look for methods that contain `execute` in
their name

```
cpg.method.name("execute.*").fullName.p 
java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)
java.sql.Statement.executeUpdate:int(java.lang.String)
java.sql.PreparedStatement.executeUpdate:int()
```

We found three methods and two of them are known to be a traditional
sink SQL injection sink, so we mark the parameter as sink.

```
ocular> val sink = cpg.method.name(".*execute.*").parameter 
```

The next step is to find a flow between the sink and source
```
ocular> sink.reachableBy(source).flows.p 
[...]
request 	 80 	 doGet 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
request 	 81 	 doGet 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
request 	 37 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
request 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
this 	  	 getParameter 	 javax/servlet/http/HttpServletRequest.java
$ret 	  	 getParameter 	 javax/servlet/http/HttpServletRequest.java
request.getParameter("email") 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
$r3 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
$r3 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
this 	  	 trim 	 java/lang/String.java
$ret 	  	 trim 	 java/lang/String.java
$r3.trim() 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
email 	 42 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
email 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param0 	  	 append 	 java/lang/StringBuilder.java
$ret 	  	 append 	 java/lang/StringBuilder.java
$r5.append(email) 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
$r6 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
$r6 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
this 	  	 append 	 java/lang/StringBuilder.java
$ret 	  	 append 	 java/lang/StringBuilder.java
$r6.append("\'") 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
$r7 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
$r7 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
this 	  	 toString 	 java/lang/StringBuilder.java
$ret 	  	 toString 	 java/lang/StringBuilder.java
$r7.toString() 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param1 	  	 <operator>.assignment 	 N/A
param0 	  	 <operator>.assignment 	 N/A
$r8 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
$r8 	 48 	 processRequest 	 org/cysecurity/cspf/jvl/controller/EmailCheck.java
param0 	  	 executeQuery 	 java/sql/Statement.java
[...]
```


The flows can be examined manually or automatically. For example, we
can determine parameters we control as a result of data flows as
follows:

```
sinks.reachableBy(sources).flows.l.flatMap(_.pathElems.last.parameters.l)
```

The query determines sinks reachable by sources and examines the
corresponding data flows. The last flow element is extracted of each
flow via the `pathElemens.last` directive, and the corresponding
parameter is retrieved. The result of the query can be stored in a
variable for further processing, which comes in handy when determining
a large number of data flows:

```
val controlled = sinks.reachableBy(sources).flows.l.flatMap(_.pathElems.last.parameters.l)
```
We can now retrieve the parameter index ("order" and method full name):

```
controlled.map(x => s"Controlling parameter ${x.order} of ${x.start.method.fullName.l.head}")
res14: List[String] = List(
  "Controlling parameter 1 of java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)",
  "Controlling parameter 1 of java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)",
  "Controlling parameter 1 of java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)"
)
```


## Specifying data-flow patterns to scan for via Policy

The CPG query language can be used to formulate vulnerability
patterns, and they can be placed into a non-interactive script to
automatically scan for vulnerability patterns. For data-flow related
vulnerabilities, the ShiftLeft tooling provides a more concise
mechanism, security policy. The security policy defines methods that
introduce data into the application, sensitive operations, and
finally, data-flow that should be reported. For example, in
ShiftLeft's dynamic policy, you can find the following lines:

```
// [~/.shiftleft/policy/dynamic/java/sql/Statement.policy:]
IO sql = METHOD -f "java.sql.Statement.executeQuery:java.sql.ResultSet(java.lang.String)" { PAR -i 1 "SINK" }
```

This states that the first parameter of the method `executeQuery` should be considered as a data sink of a sql query.

```
EXPOSED http = SUPERTYPE -f "javax.servlet.http.HttpServlet" METHOD -n r"do(Get|Post|Delete|Put|Head|Options|Trace)" { PAR -t "javax.servlet.http.HttpServletRequest" "SOURCE" } 
```

This rule specifies that all parameters of the methods
`do(Get|Post|Delete|Put|Head|Options|Trace)` with the type
`javax.servlet.http.HttpServletRequest` are tagged as `http`.
Furthermore the class that implements these methods needs to derive
`javax.servlet.http.HttpServlet`.

Finally, we can specify that flows of `http` data into `sql`, without
any escaping, encrypting, encoding or hashing are worth reporting:
```
// ~/.shiftleft/policy/static/sqlinjection.policy:

CONCLUSION http-to-sql = FLOW IO (http) -> DATA (NOT encrypted AND NOT hashed AND NOT encoded AND NOT escaped) -> IO (sql)
WHEN CONCLUSION http-to-sql => EMIT {
  title: "SQL Injection",
  description: "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This could allow an attacker to read sensitive dat a from the database or modify its content.See http://cwe.mitre.org/data/definitions/89.html",
  category: "a1-injection",
  score: "9.0"
}
```


The policy language additionally allows data transformations and
checks to be specified in order to report flows of data, only if data
does not undergo validation. For a detailed description of the query
language, please see Policy language.

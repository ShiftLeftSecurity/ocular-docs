# Finding previously unknown vulnerabilities by example (CVE-2018-19859)

This tutorial is a more technical write up of the blog entry about the discovery of CVE-2018-19859, an arbitrary file write in [OpenRefine](https://github.com/OpenRefine/OpenRefine/). Remember to checkout our other tutorials about persisting your queries, to safe future time and work effort!

[OpenRefine](https://github.com/OpenRefine/OpenRefine/) is described by its authors as "a free, open source power tool for working with messy data and improving it". It is used, for example, by Journalists to clean up messy public data sets prior to statistical calculations. To enable this, it provides mechanisms for importing and exporting data, often split into multiple files or packed into archives.

## CVE-2018-19859

The CVE is about a directory traversal attack, however, it is a de-facto arbitrary file write! The vulnerability is rooted in an unsafe zip file handling and is a very [old vulnerability pattern](http://phrack.org/issues/34/5.html#article) but it just won't die. It is definitely a vulnerability type that goes well in the portfolio of every security researcher, analyst, and pentester.

## Creating the CPG
OpenRefine does not come packaged into a single executable jar or war file as expected by `java2cpg`. Luckily, `java2cpg` is rather forgiving when it comes to JAR file structure: a zip file named "jar" containing the class files of interest is perfectly sufficient. We build this file as follows.

```
wget https://github.com/OpenRefine/OpenRefine/releases/download/3.1/openrefine-linux-3.1.tar.gz
tar xfz openrefine-linux-3.1.tar.gz
find openrefine-3.1 -name *.class | zip openrefine.jar -@
```
We then run `java2cpg`, specifying that we wish to include the application code from the namespaces `com.google.refine` and `org.openrefine` for this CPG.

```
./java2cpg.sh openrefine.jar -w com.google.refine,org.openrefine -nb -o openrefine.bin.zip
```

Finally, we load the newly created CPG into ocular

```
./ocular.sh
ocular> loadCpg("openrefine.bin.zip")
```

## Identifying importers

We start looking for imports by looking for all methods that contain the substring "Import" in their method name. This search yields 409 methods, and is thus still a bit too generic.

```
ocular> cpg.method.fullName(".*Import.*").toList.size 
409
```
We narrow in on importers that we can access via HTTP by making use of a naming convention often found in [Java Servlet](https://en.wikipedia.org/wiki/Servlet) code: often HTTP Get handlers are named `doGet`, while HTTP POST handlers are named `doPost`. By executing the query below, the number of results is decreased to 9 methods, which we can easily review manually.

```
ocular> cpg.method.fullName(".*Import.*do(Get|Post).*").toList.size 
> 9
```

Some methods are stored in an interesting class with the name `DefaultImportingController`. We enhance our query by replacing `Import` with `DefaultImportingController`. The result consists, not surprisingly, of a `doGet` and a `doPost` method.
```
cpg.method.fullName(".*DefaultImportingController.*do(Get|Post).*").fullName.p

com.google.refine.importing.DefaultImportingController.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
com.google.refine.importing.DefaultImportingController.doPost:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
```

Looks like we found a interesting source and only used three queries! 

While we found the method we still need to create a source for the data flow. The query below defines a source and reduces the number of starting points to `HttpServletRequest` parameter of the variables. Sometimes the `HttpServletResponse` is also interesting but as we mentioned earlier, we start with the low hanging fruits. 

```
ocular> val source = cpg.method
                        .fullName(".*DefaultImportingController."+
                                  "*do(Get|Post).*")
                        .parameter
                        .evalType(".*HttpServletRequest.*")
```
Alright, we are done in this section and have a nice source and a good starting point.

## Looking for the sink

The sink is the second of the three parts of finding the vulnerability and thus get a lot of fame for our CVE! We jump right in and remember that we want to look for a unzipping vunerability as we mentioned in the introduction. 

We can use a very easy query to identify the presence of `zip` package and methods. The follwoing query shows us that we have at leas one caller to a `getName` method in a `zip` package, inside a method `explodeArchive`. 
```
ocular> cpg.method.fullName(".*zip.*getName.*").caller.fullName.p

com.google.refine.importing.ImportingUtilities.explodeArchive:boolean(java.io.File,java.io.InputStream,org.json.JSONObject,org.json.JSONArray,com.google.refine.importing.ImportingUtilities$Progress)
```

Already a good start and even it is not the final method, it is an interesting one! We can use the method as an interim goal and try to find a flow to `explodeArchive`, all we have to do is to define a sink with the following query.
```
val sink = cpg.method.name("explodeArchive").parameter
```
Finding the data flow is an intuitive query that can be paraphrased as "Show me all the flows that reach the source, starting from the sink and print them".

```
sink.reachableBy(source).flows.p
```

[todo copy and paste flow]

## Final flow
We need actually two flows for the vulnerability, one that shows us that we control the file name and that we control the content of the file. The sink changes but the source stays the same for both cases. 

The flows are too long for our default settings so we need to adjust the `maxFlowLength` in the config, 300 should be sufficient for us 
```
config.maxFlowLength = 300
```
[todo write aobut the flows]
### File write
```
val source = cpg.method
                        .fullName(".*DefaultImportingController."+
                                  "*do(Get|Post).*")
                        .parameter
                        .evalType(".*HttpServletRequest.*")
                        
val sink = cpg.method
              .fullName(".*FileOutputStream.*write.*")
              .parameter.index(1)

sink.reachableBy(source)
            .flows.passes("explodeArchive")
            .passes("allocateFile")
            .passes("saveStreamToFile").p
```

### File path
```
val source = cpg.method
                        .fullName(".*DefaultImportingController."+
                                  "*do(Get|Post).*")
                        .parameter
                        .evalType(".*HttpServletRequest.*")
val sink = cpg.method
              .fullName(".*FileOutputStream.*<init>.*")
              .parameter.index(1)
sink.reachableBy(source)
            .flows.passes("explodeArchive")
            .passes("allocateFile")
            .passes("saveStreamToFile").p
```



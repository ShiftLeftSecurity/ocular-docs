# Finding previously unknown vulnerabilities by example (CVE-2018-19859)

This tutorial is a more technical writeup of the blog entry about the discovery of CVE-2018-19859, an arbitrary file write in [OpenRefine](https://github.com/OpenRefine/OpenRefine/). Remember to checkout our other tutorials about persisting your queries, to safe future time and work effort!

[OpenRefine](https://github.com/OpenRefine/OpenRefine/) is described by its authors as `a free, open source power tool for working with messy data and improving it`. It is used, for example, by Journalists to clean up messy public data sets prior to statistical calculations. To enable this, it provides mechanisms for importing and exporting data, often split into multiple files or packed into archives.

## CVE-2018-19859

The CVE is about a directory traversal, however, it is a de-facto arbitrary file write! The vulnerability is rooted in an unsafe zip file handling. This is a very [old vulnerability type](http://phrack.org/issues/34/5.html#article) but it just won't die! It is definitely a vulnerability type that goes well in the portfolio of every security researcher, analyst, and pentester.

## Creating the CPG
Unfortuanatly OpenRefine does not come in a nice packed jar or war file, so we cannot let java2cpg do the magic to create a CPG. We need to tweak a bit [todo]

```
loadCpg("openrefine.bin.zip")
```

## Looking for the source

We start looking for imports, but our search term is too generic! 409 methods contain the value `Import` in their fullname. Note we also might catch methods with the name `org.my.NotImport.foo()`! 
```
ocular> cpg.method.fullName(".*Import.*").toList.size 
409
```

It is alsways a good idea for security researcher to check for low hanging fruit first and the lowest fruits are Servlets! If you haven't heard aboout servlets, there is plenty of documentation all over the internet, starting from [wikipedia](https://de.wikipedia.org/wiki/Servlet), going up to  [Oracle](https://docs.oracle.com/javaee/6/tutorial/doc/bnafe.html) or [tomcat](https://tomcat.apache.org/tomcat-9.0-doc/servletapi/javax/servlet/http/HttpServlet.html). 

One of the charactaristics of servlets are the `doGet`- and the `doPost`-handler, responsible for handling GET and POST requests. It is always worth a try to look for this methods in the code! 

By executing the query below we dropped by 400 and suddenly find 9 easily to manually reviewable methods.

```
ocular> cpg.method.fullName(".*Import.*do(Get|Post).*").toList.size 
> 9
```

Some methods are stored in an interesting class with the name `DefaultImportingController`. We enhance our query by replacing `Import` with `DefaultImportingController`. The result consists, not suppringly, of a `doGet` and a `doPost` method.
```
cpg.method.fullName(".*DefaultImportingController.*do(Get|Post).*").fullName.p

com.google.refine.importing.DefaultImportingController.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
com.google.refine.importing.DefaultImportingController.doPost:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
```

Looks like we found a interesting source and only used three queries! 

While we found the method we still need to create a source for the data flow. The query below defines a source and reduces the number of starting poionts to `HttpServletRequest` parameter of the variables. Sometimes the `HttpServletResponse` is also interesting but as we mentioned earlier, we start with the low hanging fruits. 

```
ocular> val source = cpg.method
                        .fullName(".*DefaultImportingController."+
                                  "*do(Get|Post).*")
                        .parameter
                        .evalType(".*HttpServletRequest.*")
```
Alright we are done in this section and ahve a nice source and a good starting point. 

## Looking for the sink

The sink is the second of the three parts of finding the vulnerability and thus get a lot of fame for our CVE! We jump right in and remember that we want to look for a unzipping vunerability as we mentioned in the introduction. 

We can use a very easy query to identify the presence of `zip` package and methods. The follwoing query shows us that we have at leas one caller to a `getName` method in a `zip` package, inside a method `explodeArchive`. 
```
ocular> cpg.method.fullName(".*zip.*getName.*").caller.fullName.p

com.google.refine.importing.ImportingUtilities.explodeArchive:boolean(java.io.File,java.io.InputStream,org.json.JSONObject,org.json.JSONArray,com.google.refine.importing.ImportingUtilities$Progress)
```

Already a good start and even it is not the final method, it is an interesting one! We can use the method as an interim goal and try to find a flow to `explodeArchive`, all we have to do is to define a sink with the following query.
```
val sink = cpg.method.name("explodeArchive").parameter
```
Finding the data flow is an intiutive query that can be paraphrased as "Show me all the flows that reach the source, starting from the sink and print them".

```
sink.reachableBy(source).flows.p
```

[todo copy and paste flow]

## Final flow
We need actually two flows for the vulnerability, one that shows us that we control the file name and an other that we controll the content of the file. The sink changes but the source stays the same for both cases. 

The flows are too long for our default settings so we need to adjust the `maxFlowLength` in the config, 300 should be sufficient for us 
```
config.maxFlowLength = 300
```
[todo write aobut the flows]
### File write
```
val source = cpg.method
                        .fullName(".*DefaultImportingController."+
                                  "*do(Get|Post).*")
                        .parameter
                        .evalType(".*HttpServletRequest.*")
                        
val sink = cpg.method
              .fullName(".*FileOutputStream.*write.*")
              .parameter.index(1)

sink.reachableBy(source)
            .flows.passes("explodeArchive")
            .passes("allocateFile")
            .passes("saveStreamToFile").p
```

### File path
```
val source = cpg.method
                        .fullName(".*DefaultImportingController."+
                                  "*do(Get|Post).*")
                        .parameter
                        .evalType(".*HttpServletRequest.*")
val sink = cpg.method
              .fullName(".*FileOutputStream.*<init>.*")
              .parameter.index(1)
sink.reachableBy(source)
            .flows.passes("explodeArchive")
            .passes("allocateFile")
            .passes("saveStreamToFile").p

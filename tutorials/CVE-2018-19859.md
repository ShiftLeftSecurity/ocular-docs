# Finding real world vulnerabilities

This tutorial is a more technical writeup of the blog entry (TODO). Remember to checout our other tutorials about persisting your queries, to safe future time and work effort!

[to intoroduce openrefine]

## CVE-2018-19859

The CVE is about a directory traversal but is de facto a arbitrary file write! The vulnerability is rooted in an unsafe zip file handling. This is a very old vulnerability but it just wont die!


## Creating the CPG
Unfortuanatly OpenRefine does not come in a nice packed jar or war file, so we cannot let java2cpg do the magic to create a CPG. We need to tweak a bit [todo]

```
loadCpg("openrefine.bin.zip")
```

## Looking for the source

We start looking for imports, but our search term is too generic! 409 methods contain the value `Import` in their fullname. Note we also might catch methods with the name `org.my.NotImport.foo()`! 
```
ocular> cpg.method.fullName(".*Import.*").toList.size 
409
```

It is alsways a good idea for security researcher to check for low hanging fruits first and the lowest fruits are Servlet! If you haven't heard aboout servlets, there is plenty of documentation all over the internet, starting from [wikipedia](https://de.wikipedia.org/wiki/Servlet), going up to  [Oracle](https://docs.oracle.com/javaee/6/tutorial/doc/bnafe.html) or [tomcat](https://tomcat.apache.org/tomcat-9.0-doc/servletapi/javax/servlet/http/HttpServlet.html). 

One of the charactaristics of servlets are the `doGet`- and the `doPost`-handler, responsible for handling GET and POST requests. It is always worth a try to look for this methods in the code! 

By executing the query below we dropped by 400 and suddenly find 9 easily to manually reviewable methods.

```
ocular> cpg.method.fullName(".*Import.*do(Get|Post).*").toList.size 
> 9
```

Some methods are stored in an interesting class with the name `DefaultImportingController`. We enhance our query by replacing `Import` with `DefaultImportingController`. The result consists, not suppringly, of a `doGet` and a `doPost` method.
```
cpg.method.fullName(".*DefaultImportingController.*do(Get|Post).*").fullName.p

com.google.refine.importing.DefaultImportingController.doGet:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
com.google.refine.importing.DefaultImportingController.doPost:void(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)
```

Looks like we found a intersting source and only used three queries! 

While we found the method we still need to create a source for the data flow. The query below defines a source and reduces the number of starting poionts to `HttpServletRequest` parameter of the variables. Sometimes the `HttpServletResponse` is also interesting but as we mentioned earlier, we start with the low hanging fruits. 

```
ocular> val source = cpg.method
                        .fullName(".*DefaultImportingController."+
                                  "*do(Get|Post).*")
                        .parameter
                        .evalType(".*HttpServletRequest.*")
```
Alright we are done in this section and ahve a nice source and a good starting point. 

## Looking for the sink

The sink is the second of the three parts of finding the vulnerability and thus get a lot of fame for our CVE! We jump right in and remember that we want to look for a unzipping vunerability as we mentioned in the introduction. 

We can use a very easy query to identify the presence of `zip` package and methods. The follwoing query shows us that we have at leas one caller to a `getName` method in a `zip` package, inside a method `explodeArchive`. 
```
ocular> cpg.method.fullName(".*zip.*getName.*").caller.fullName.p

com.google.refine.importing.ImportingUtilities.explodeArchive:boolean(java.io.File,java.io.InputStream,org.json.JSONObject,org.json.JSONArray,com.google.refine.importing.ImportingUtilities$Progress)
```

Already a good start and even it is not the final method, it is an interesting one! We can use the method as an interim goal and try to find a flow to `explodeArchive`, all we have to do is to define a sink with the following query.
```
val sink = cpg.method.name("explodeArchive").parameter
```
Finding the data flow is an intiutive query that can be paraphrased as "Show me all the flows that reach the source, starting from the sink and print them".

```
sink.reachableBy(source).flows.p
```


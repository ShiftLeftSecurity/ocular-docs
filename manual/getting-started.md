# Getting Started

This tutorial walks you through the core features of the ShiftLeft Command Line Tools. The tutorial demonstrates how the tooling can be used to:

* automatically scan programs for vulnerabilities
* interactively query the code property graph to uncover attack surface
* formulate ad-hoc queries to identify vulnerabilities
* customize the scanner's detection rules
* automatically scan and generate a report via non-interactive scripts

The philosophy behind our tooling is that, while creating a "one-fits-all" vulnerability scanner borders on the impossible, you can certainly provide the tooling that vulnerability researchers require to explore code bases in order to determine vulnerability patterns, formulate these patterns in concise and expressive languages, and persist them, such that code can be automatically scanned for these patterns in the future. Instead of only showcasing the tooling's default capabilities, in this tutorial we also demonstrate the many ways in which the tooling can be adapted and extended to suit your specific needs.

# Prerequisites

Install the ShiftLeft Command Line Tools into local directory `$shiftleft` as described in the [installation documentation](installation.html).

# Running example

This tutorial is based on the sample application "Hello-ShiftLeft" which you can find in the directory `subjects` provided with the ShiftLeft Command Line Tools distribution.

Hello-Shiftleft is a Spring-based Web application which contains different sample vulnerabilities, including typical injection vulnerabilities and leakages of sensitive information. Throughout this guide, we focus on an object deserialization vulnerability in the `AdminController` shown in the listing below.

```java
...
@Controller
public class AdminController {
...
@RequestMapping(value = "/admin/login", method = RequestMethod.POST)
public String doPostLogin(
  @CookieValue(value = "auth", defaultValue = "notset") String auth,
  @RequestBody String password, HttpServletResponse response,
  HttpServletRequest request) throws Exception {
...
if (!auth.equals("notset")) {
   if(isAdmin(auth)) {
     request.getSession().setAttribute("auth",auth);
     return succ;
   }
 }
 ...
}
...
private boolean isAdmin(String auth) {
try {
	ByteArrayInputStream bis = new ByteArrayInputStream(
  	Base64.getDecoder().decode(auth));
	ObjectInputStream objectInputStream = new ObjectInputStream(bis);
	Object authToken = objectInputStream.readObject();
  return ((AuthToken) authToken).isAdmin();
	} catch (Exception ex) {
   	System.out.println(" cookie cannot be deserialized: "
                      +ex.getMessage());
   	return false;
	}
}
...
```



In this code fragment, a cookie is received via HTTP and eventually deserialized to create a Java object, an optimistic practice that can often be exploited by attackers for arbitrary code execution.

## Generating Code Property Graphs and Security Profiles

Once the tools are installed, we begin by generating a code property graph (CPG) for the `hello-shiftleft.jar`:

```bash
cd $shiftleft
./java2cpg.sh subjects/hello-shiftleft-0.0.1-SNAPSHOT.jar -o cpg.bin.zip
```

This command creates a file named `cpg.bin.zip` containing the code property graph in a binary format.

The CPG can be automatically analyzed using the `cpg2sp` tool to determine potentially vulnerable flows and summarize them in a *security profile*:

```bash
./cpg2sp.sh --cpg ./cpg.bin.zip -o hello.sp
```

This command creates a file named `hello.sp` containing the security profile from the CPG in `cpg.bin.zip`. The security profile is generated by evaluating the security policy in `~/.shiftleft/policy/` against the CPG.

(For additional output formats, refer to the
[java2cpg](java2cpg.md) and [cpg2sp](cpg2sp.md) documentation,
respectively).

# Generating an Initial Scan Report

The ShiftLeft Command Line Tools let you query, interactively and non-interactively, code property graphs and security profiles. For example, consider the script in `scripts/report.sc`:

```scala
@main def exec(spFilename: String, outFilename: String) = {
  loadSp(spFilename)
  sp.findings.sortedByScore.l |> outFilename
}
```

This script loads the security profile at `spFilename`, and evaluates the expression `sp.findings.sortedByScore.l` to obtain a list of findings sorted by score. The list is piped to the file `outFilename` via the `|>` operator.

You can run this script as follows:

```bash
./ocular.sh --script scripts/report.sc --params spFilename=hello.sp,outFilename=report.txt
```

As a result, the text file `report.txt` is generated, which contains all findings in a human-readable format. Let's take a look at one the the findings to get an idea of the type of information the report contains:

```
Title: attacker-to-deserializer
Score: 8.0
Categories: [a1-injection]
Flow ids: [2963]
Description: Attacker controlled data is deserialized in this flow. This can lead to an ...
Flow 0:
IO Tags: Set(http) -> Set()
Data Tags: Set(DATA_TYPE: attacker-controlled, TRANSFORMER_TYPE: -base64encoded)
routes: Set(/admin/login)
trigger methods:
io.shiftleft.controller.AdminController.doPostLogin:java.lang.String(java.lang.String,java.lang.String,javax.servlet.http.HttpServletResponse,javax.servlet.http.HttpServletRequest)

Primary flow:
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
| param     | type                        | method     | signature                                                                                                                                                                           |
|============================================================================================================================================================================================================================================|
| auth(1)   | java.lang.String            | doPostLogin| io.shiftleft.controller.AdminController.doPostLogin:java.lang.String(java.lang.String,java.lang.String,javax.servlet.http.HttpServletResponse,javax.servlet.http.HttpServletRequest)|
| auth(1)   | java.lang.String            | isAdmin    | io.shiftleft.controller.AdminController.isAdmin:boolean(java.lang.String)                                                                                                           |
| param0(1) | java.lang.String            | decode     | java.util.Base64$Decoder.decode:byte[](java.lang.String)                                                                                                                            |
| return(-1)| byte[]                      | decode     | java.util.Base64$Decoder.decode:byte[](java.lang.String)                                                                                                                            |
| param0(1) | byte[]                      | <init>     | java.io.ByteArrayInputStream.<init>:void(byte[])                                                                                                                                    |
| this(0)   | java.io.ByteArrayInputStream| <init>     | java.io.ByteArrayInputStream.<init>:void(byte[])                                                                                                                                    |
| param0(1) | java.io.InputStream         | <init>     | java.io.ObjectInputStream.<init>:void(java.io.InputStream)                                                                                                                          |
| this(0)   | java.io.ObjectInputStream   | <init>     | java.io.ObjectInputStream.<init>:void(java.io.InputStream)                                                                                                                          |
```

This finding identifies a potential deserialization vulnerability triggerable via HTTP, an injection vulnerability with a score of 8.0. Findings are scored in order to allow for filtering. Findings also include a human-readable description that further characterizes the potential vulnerability, as well as the information flows associated with the vulnerability.

In this example, a single information flow is associated with the vulnerability. Ocular analyzer identifies that the parameter `auth` of the method `doPostLogin` is attacker-controlled with high probability as it is an HTTP request header. Tracking the flow of `auth`, the variable is passed into the method `isAdmin` where it is Base64-decoded and used in the initialization of a `ByteArrayInputStream`. This input stream is itself used to initialize an `ObjectInputStream`. Lastly, the `readObject` method is invoked on the tainted input stream, resulting in the deserialization of attacker-controlled data. The flow description additionally provides HTTP input routes when possible (`/admin/login` in this case), and externally triggerable methods to invoke the vulnerable flow (`doPostLogin` in this example).

# Interactively exploring and filtering security profiles

Security profiles can be explored interactively on Ocular using a domain specific language. Ocular can be started as follows:

```
> sh ocular.sh                                                                                                                  
Compiling (synthetic)/ammonite/predef/interpBridge.sc
Commands:
helpMsg                         // prints this help dialog
status                          // prints the current status
loadCpg("path/to/file.[xml|gryo|bin.zip]") // loads cpg (format inferred from suffix)
loadSp("path/to/file.[sp]")                        // load sp

Ocular status:
No CPG currently loaded.
CPG can be loaded via a `loadCpg` command. See `help`.
Welcome to ShiftLeft Ocular
ocular>  
```

As demonstrated in the non-interactive script `report.sc`, we can load the security profile "hello.sp" by issuing the command:

```scala
loadSp("hello.sp")
```

This creates an object named `sp` that provides access to the security profile. Ocular offers tab-completion to facilitate learning of the domain specific query language. For example, you can enter

```scala
sp.findings.<TAB>
!=             category       equals         getClass       isInstanceOf   raw            scoreAtMost    spTestsFlows   |>
==             dedup          filter         hashCode       l              score          size           title
asInstanceOf   description    flatMap        ioFlows        map            scoreAtLeast   sortedByScore  toString
```

to obtain a list of possible operations that can be executed on findings. In particular, findings support the `scoreAtLeast` method, which allows findings to be filtered such that only findings scored above or equal to a threshold are returned. For example,

```scala
sp.findings.scoreAtLeast(8).l.size
```

returns only findings with a score of at least 8. Please note that the query language is lazily evaluated, that is, `sp.findings.scoreAtLeast(8)` only yields in an expression, and it is only evaluated as it is converted to a list via the `l` directive (a shorthand for "toList").

All string properties support regular expressions. For example, you can obtain all findings related to serialization as follows:

```scala
sp.findings.title(".*serialize.*").l
```

All lists support the functional combinators of the Scala language. Moreover, we provide the functional combinators `filter`, `map`, and `flatMap` directly for expression of the DSL. For example, instead of using the builting method `scoreAtLeast`, the same effect can be achieved via a filter operation:

```scala
sp.findings.filter(_.score >= 8).size
```

This allows more complex filtering rules to be expressed via lambdas. For example,

```scala
sp.findings.filter(x =>  x.score >=8 && x.categories.contains("a1-injection")).l
```

returns only the findings with a score greater or equal to 8, where the finding's categories includes "a1-injection".

# Uncovering attack surface with the code property graph

The code property graph contains information about the processed code on different levels of abstraction, from dependencies, to type hierarchies, control flow, data flow, and instruction-level information. Like the SP, the CPG can be queried interactively via Ocular or via non-interactive scripts. We now illustrate interactive querying, however, all queries can also be used as-in in interactive scripts.

The CPG is loaded via the `loadCpg` command:

```scala
loadCpg("cpg.bin.zip")
```

This creates an object named `cpg`, which provides access to the code property graph. We begin by exploring the program dependencies:

```scala
cpg.dependency.name.l
```

This provides a list of all dependency names. We support functional combinators. For example, to output (name, version) pairs, we can use the following expression:

```scala
cpg.dependency.map(x => (x.name, x.version)).l
```

which yields
```scala
List[(String, String)] = List(
  ("zt-exec", "1.9"),
  ("httpclient", "4.3.4"),
  ("lombok", "1.16.6"),
  ("commons-io", "2.5"),
  ("joda-time", "unknown"),
  ("jasypt", "1.9.2"),
  ("jackson-databind", "unknown"),
  ("spring-boot-starter-web", "unknown"),
  ("jasypt-spring-boot-starter", "1.11"),
  ("spring-boot-starter-test", "unknown"),
  ("spring-web", "unknown"),
  ("hsqldb", "unknown"),
  ("jackson-mapper-asl", "1.5.6"),
  ("spring-boot-starter-actuator", "unknown"),
  ("spring-boot-starter-data-jpa", "unknown"),
  ("logback-core", "1.1.9"),
  ("spring-web", "4.3.6.RELEASE"),
  ("tomcat-embed-websocket", "8.5.11"),
  ...
)
```

It is also possible to process CPG sub graphs via external programs by exporting them to JSON. For example,

```scala
cpg.dependency.toJson |> "/tmp/dependencies.json"
```

dumps dependency information into the file "/tmp/dependencies.json" is JSON format. Fields of the CPG can be queried using regular expressions. For example, to determine whether an application uses the spring framework, a quick query could be

```scala
cpg.dependency.name(".*spring.*").l.nonEmpty
=> true
```

Since the application uses Spring, it makes sense to look for the typical Java annotations that indicate attacker-controlled variables.

```scala
cpg.annotation.name(".*(CookieValue|PathVariable).*").l
```

From annotations, we can jump to parameters using these annotations:

```scala
cpg.annotation.name(".*(CookieValue|PathVariable).*").parameter.name.l
```

which yields

```scala
List[String] = List("customerId", "customerId", "customerId", "accountId", "accountId", "accountId", "accountId", "auth", "auth")
```

We can now track these attacker-controlled variables to see all data flows originating at them. To do this, we first define the set of sinks to be all parameters annotated by CookieValue or PathVariable:

```scala
val sources = cpg.annotation.name(".*(CookieValue|PathVariable).*").parameter
```

We then define the set of sinks to be all parameters:

```scala
val sinks = cpg.method.parameter
```

Finally, we enumerate all flows from sources to sinks:

```scala
sinks.reachableBy(sources).flows.p
```

The flows can be examined manually or automatically. For example, we can determine parameters we control as a result of data flows as follows:

```scala
sinks.reachableBy(sources).flows.sink.isParameter.l
```

The query determines sinks reachable by sources and examines the corresponding data flows. The last flow element is extracted of each flow via the `pathElemens.last` directive, and the corresponding parameter is retrieved. The result of the query can be stored in a variable for further processing, which comes in handy when determining a large number of data flows:

```scala
val controlled = sinks.reachableBy(sources).flows.sink.isParameter.l
```

We can now retrieve the parameter index ("ast child number" and method full name):

```scala
controlled.map(x => s"Controlling parameter ${x.astChildNum} of ${x.start.method.fullName.l.head}")
```

yielding

```scala
"Controlling parameter 1 of java.lang.Long.valueOf:java.lang.Long(long)",
"Controlling parameter 1 of java.lang.Long.valueOf:java.lang.Long(long)",
"Controlling parameter 1 of java.lang.Long.valueOf:java.lang.Long(long)",
"Controlling parameter 1 of java.lang.Long.valueOf:java.lang.Long(long)",
"Controlling parameter 0 of java.lang.String.equals:boolean(java.lang.Object)",
"Controlling parameter 1 of java.io.ObjectInputStream.<init>:void(java.io.InputStream)",
<b>"Controlling parameter 0 of java.io.ObjectInputStream.readObject:java.lang.Object()",</b>
"Controlling parameter 0 of io.shiftleft.model.AuthToken.isAdmin:boolean()",
"Controlling parameter 1 of io.shiftleft.repository.AccountRepository.findOne:java.lang.Object(java.io.Serializable)",
"Controlling parameter 1 of io.shiftleft.repository.AccountRepository.findOne:java.lang.Object(java.io.Serializable)",
"Controlling parameter 1 of io.shiftleft.repository.AccountRepository.findOne:java.lang.Object(java.io.Serializable)",
"Controlling parameter 1 of io.shiftleft.repository.AccountRepository.findOne:java.lang.Object(java.io.Serializable)",
"Controlling parameter 1 of io.shiftleft.repository.CustomerRepository.findOne:java.lang.Object(java.io.Serializable)",
"Controlling parameter 1 of io.shiftleft.repository.CustomerRepository.exists:boolean(java.io.Serializable)",
"Controlling parameter 1 of io.shiftleft.repository.CustomerRepository.exists:boolean(java.io.Serializable)",
"Controlling parameter 1 of io.shiftleft.repository.CustomerRepository.delete:void(java.io.Serializable)",
"Controlling parameter 1 of java.util.Base64$Decoder.decode:byte[](java.lang.String)",
"Controlling parameter 1 of io.shiftleft.controller.AdminController.isAdmin:boolean(java.lang.String)",
"Controlling parameter 1 of java.io.ByteArrayInputStream.<init>:void(byte[])",
"Controlling parameter 2 of javax.servlet.http.HttpSession.setAttribute:void(java.lang.String,java.lang.Object)",
...
```


In particular, we see that the instance parameter (with an index of 0) of the method `ObjectInputStream.readObject` is controlled, that is, the deserialization vulnerability exists. This shows a more exploratory way of identifying the vulnerability.

# Specifying data-flow patterns to scan for via Policy

The CPG query language can be used to formulate vulnerability patterns, and they can be placed into a non-interactive script to automatically scan for vulnerability patterns. For data-flow related vulnerabilities, the ShiftLeft tooling provides a more concise mechanism, security policy. The security policy defines methods that introduce data into the application, sensitive operations, and finally, data-flow that should be reported. For example, in ShiftLeft's default policy, you can find the following lines:

```
// [~/.shiftleft/policy/dynamic/java/io/ObjectInputStream.policy:]

IO deserializer = METHOD -f "java.io.ObjectInputStream.readObject:java.lang.Object()" { INST "SINK" }
```

This states that the instance parameter of the method `readObject` should be considered as a data sink of a deserializer, that is, the instance parameter is deserialized.

```
// ~/.shiftleft/policy/dynamic/org/springframework/exposed.policy:

TAG "DATA_TYPE" -v "attacker-controlled" METHOD -a r"org\.springframework\.web\.bind\.annotation\.(Request|Get|Post|Put|Delete|Patch)Mapping" PAR -a r"org\.springframework\.web\.bind\.annotation\.(CookieValue|PathVariable|RequestParam|RequestBody)"
```

This rule specifies that all parameters tagged with the Spring annotations "CookieValue", "PathVariable", and a few others are to be tagged as "attacker-controlled. Finally, we can specify that flows of attacker-controlled data into deserializers are worth reporting:

```
// ~/.shiftleft/policy/static/execute.policy:

CONCLUSION attacker-to-deserializer = FLOW DATA (attacker-controlled) -> IO (deserializer)
WHEN CONCLUSION attacker-to-deserializer => EMIT {
    title: "Attacker controlled data to deserialization",
    description: "Attacker controlled data is deserialized in this flow. ...",
    category: "a1-injection",
    score: "8.0"
}
```

The policy language additionally allows data transformations and checks to be specified in order to report flows of data, only if data does not undergo validation. For a detailed description of the query language, please see [Policy language](policy.md).

# Extending the DSL via the "Pimp my library" pattern

The domain specific language can be enhanced by the user via the "Pimp my library pattern". For example, in the following script, a method named `whatICareAbout` is added to findings, which can subsequently be evaluated on findings just like built in language elements:

```scala
import io.shiftleft.libsecurityprofile.steps.SpFinding

class MyMethods(findings : SpFinding) {
    <b>def whatICareAbout = findings.filter(x => x.score >= 8 && x.categories.contains("a1-injection"))</b>
}

implicit def conv(findings: SpFinding) = new MyMethods(findings)

@main def exec(spFilename: String, outFilename: String) = {
    loadSp(spFilename)
    sp.findings.whatICareAbout.l |> outFilename
}
```

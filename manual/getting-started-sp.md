# Getting started with Security Profiles

This tutorial continues to walk you through the core features of
Ocular. The tutorial demonstrates how the tooling can be used to:

* automatically scan programs for vulnerabilities
* customize the scanner's detection rules
* automatically scan and generate a report via non-interactive scripts

# Prerequisites

Install Ocular into local directory `$shiftleft` as described in the
[installation documentation](installation.html).

# Running example

This tutorial is based on the sample application "Hello-ShiftLeft" which you can find in the directory `subjects` provided with the ShiftLeft Command Line Tools distribution.

Hello-Shiftleft is a Spring-based Web application which contains different sample vulnerabilities, including typical injection vulnerabilities and leakages of sensitive information. Throughout this guide, we focus on an object deserialization vulnerability in the `AdminController` shown in the listing below.

```java
...
@Controller
public class AdminController {
...
@RequestMapping(value = "/admin/login", method = RequestMethod.POST)
public String doPostLogin(
  @CookieValue(value = "auth", defaultValue = "notset") String auth,
  @RequestBody String password, HttpServletResponse response,
  HttpServletRequest request) throws Exception {
...
if (!auth.equals("notset")) {
   if(isAdmin(auth)) {
     request.getSession().setAttribute("auth",auth);
     return succ;
   }
 }
 ...
}
...
private boolean isAdmin(String auth) {
try {
	ByteArrayInputStream bis = new ByteArrayInputStream(
  	Base64.getDecoder().decode(auth));
	ObjectInputStream objectInputStream = new ObjectInputStream(bis);
	Object authToken = objectInputStream.readObject();
  return ((AuthToken) authToken).isAdmin();
	} catch (Exception ex) {
   	System.out.println(" cookie cannot be deserialized: "
                      +ex.getMessage());
   	return false;
	}
}
...
```

In this code fragment, a cookie is received via HTTP and eventually
deserialized to create a Java object, an optimistic practice that can
often be exploited by attackers for arbitrary code execution. 

## Generating Code Property Graphs and Security Profiles

Once the tools are installed, we begin by generating a code property graph (CPG) for the `hello-shiftleft.jar`:

```bash
cd $shiftleft
./java2cpg.sh subjects/hello-shiftleft-0.0.1-SNAPSHOT.jar -o cpg.bin.zip
```

This command creates a file named `cpg.bin.zip` containing the code property graph in a binary format.

The CPG can be automatically analyzed using the `cpg2sp` tool to determine potentially vulnerable flows and summarize them in a *security profile*:

```bash
./cpg2sp.sh --cpg ./cpg.bin.zip -o hello.sp
```

This command creates a file named `hello.sp` containing the security profile from the CPG in `cpg.bin.zip`. The security profile is generated by evaluating the security policy in `~/.shiftleft/policy/` against the CPG.

(For additional output formats, refer to the
[java2cpg](java2cpg.md) and [cpg2sp](cpg2sp.md) documentation,
respectively).

# Generating an Initial Scan Report

The ShiftLeft Command Line Tools let you query, interactively and non-interactively, code property graphs and security profiles. For example, consider the script in `scripts/report.sc`:

```scala
@main def exec(spFilename: String, outFilename: String) = {
  loadSp(spFilename)
  sp.findings.sortedByScore.l |> outFilename
}
```

This script loads the security profile at `spFilename`, and evaluates the expression `sp.findings.sortedByScore.l` to obtain a list of findings sorted by score. The list is piped to the file `outFilename` via the `|>` operator.

You can run this script as follows:

```bash
./ocular.sh --script scripts/report.sc --params spFilename=hello.sp,outFilename=report.txt
```

As a result, the text file `report.txt` is generated, which contains all findings in a human-readable format. Let's take a look at one the the findings to get an idea of the type of information the report contains:

```
Title: attacker-to-deserializer
Score: 8.0
Categories: [a1-injection]
Flow ids: [2963]
Description: Attacker controlled data is deserialized in this flow. This can lead to an ...
Flow 0:
IO Tags: Set(http) -> Set()
Data Tags: Set(DATA_TYPE: attacker-controlled, TRANSFORMER_TYPE: -base64encoded)
routes: Set(/admin/login)
trigger methods:
io.shiftleft.controller.AdminController.doPostLogin:java.lang.String(java.lang.String,java.lang.String,javax.servlet.http.HttpServletResponse,javax.servlet.http.HttpServletRequest)

Primary flow:
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
| param     | type                        | method     | signature                                                                                                                                                                           |
|============================================================================================================================================================================================================================================|
| auth(1)   | java.lang.String            | doPostLogin| io.shiftleft.controller.AdminController.doPostLogin:java.lang.String(java.lang.String,java.lang.String,javax.servlet.http.HttpServletResponse,javax.servlet.http.HttpServletRequest)|
| auth(1)   | java.lang.String            | isAdmin    | io.shiftleft.controller.AdminController.isAdmin:boolean(java.lang.String)                                                                                                           |
| param0(1) | java.lang.String            | decode     | java.util.Base64$Decoder.decode:byte[](java.lang.String)                                                                                                                            |
| return(-1)| byte[]                      | decode     | java.util.Base64$Decoder.decode:byte[](java.lang.String)                                                                                                                            |
| param0(1) | byte[]                      | <init>     | java.io.ByteArrayInputStream.<init>:void(byte[])                                                                                                                                    |
| this(0)   | java.io.ByteArrayInputStream| <init>     | java.io.ByteArrayInputStream.<init>:void(byte[])                                                                                                                                    |
| param0(1) | java.io.InputStream         | <init>     | java.io.ObjectInputStream.<init>:void(java.io.InputStream)                                                                                                                          |
| this(0)   | java.io.ObjectInputStream   | <init>     | java.io.ObjectInputStream.<init>:void(java.io.InputStream)                                                                                                                          |
```
This finding identifies a potential deserialization vulnerability triggerable via HTTP, an injection vulnerability with a score of 8.0. Findings are scored in order to allow for filtering. Findings also include a human-readable description that further characterizes the potential vulnerability, as well as the information flows associated with the vulnerability.

In this example, a single information flow is associated with the vulnerability. Ocular analyzer identifies that the parameter `auth` of the method `doPostLogin` is attacker-controlled with high probability as it is an HTTP request header. Tracking the flow of `auth`, the variable is passed into the method `isAdmin` where it is Base64-decoded and used in the initialization of a `ByteArrayInputStream`. This input stream is itself used to initialize an `ObjectInputStream`. Lastly, the `readObject` method is invoked on the tainted input stream, resulting in the deserialization of attacker-controlled data. The flow description additionally provides HTTP input routes when possible (`/admin/login` in this case), and externally triggerable methods to invoke the vulnerable flow (`doPostLogin` in this example).

# Interactively exploring and filtering security profiles

Security profiles can be explored interactively on Ocular using a domain specific language. Ocular can be started as follows:

```
> sh ocular.sh                                                                                                                  
Compiling (synthetic)/ammonite/predef/interpBridge.sc
Commands:
helpMsg                         // prints this help dialog
status                          // prints the current status
loadCpg("path/to/file.[xml|gryo|bin.zip]") // loads cpg (format inferred from suffix)
loadSp("path/to/file.[sp]")                        // load sp

Ocular status:
No CPG currently loaded.
CPG can be loaded via a `loadCpg` command. See `help`.
Welcome to ShiftLeft Ocular
ocular>  
```

As demonstrated in the non-interactive script `report.sc`, we can load the security profile "hello.sp" by issuing the command:

```scala
loadSp("hello.sp")
```

This creates an object named `sp` that provides access to the security profile. Ocular offers tab-completion to facilitate learning of the domain specific query language. For example, you can enter

```scala
sp.findings.<TAB>
!=             category       equals         getClass       isInstanceOf   raw            scoreAtMost    spTestsFlows   |>
==             dedup          filter         hashCode       l              score          size           title
asInstanceOf   description    flatMap        ioFlows        map            scoreAtLeast   sortedByScore  toString
```

to obtain a list of possible operations that can be executed on findings. In particular, findings support the `scoreAtLeast` method, which allows findings to be filtered such that only findings scored above or equal to a threshold are returned. For example,

```scala
sp.findings.scoreAtLeast(8).l.size
```

returns only findings with a score of at least 8. Please note that the query language is lazily evaluated, that is, `sp.findings.scoreAtLeast(8)` only yields in an expression, and it is only evaluated as it is converted to a list via the `l` directive (a shorthand for "toList").

All string properties support regular expressions. For example, you can obtain all findings related to serialization as follows:

```scala
sp.findings.title(".*serialize.*").l
```

All lists support the functional combinators of the Scala language. Moreover, we provide the functional combinators `filter`, `map`, and `flatMap` directly for expression of the DSL. For example, instead of using the builting method `scoreAtLeast`, the same effect can be achieved via a filter operation:

```scala
sp.findings.filter(_.score >= 8).size
```

This allows more complex filtering rules to be expressed via lambdas. For example,

```scala
sp.findings.filter(x =>  x.score >=8 && x.categories.contains("a1-injection")).l
```

returns only the findings with a score greater or equal to 8, where the finding's categories includes "a1-injection".
# Specifying data-flow patterns to scan for via Policy

The CPG query language can be used to formulate vulnerability patterns, and they can be placed into a non-interactive script to automatically scan for vulnerability patterns. For data-flow related vulnerabilities, the ShiftLeft tooling provides a more concise mechanism, security policy. The security policy defines methods that introduce data into the application, sensitive operations, and finally, data-flow that should be reported. For example, in ShiftLeft's default policy, you can find the following lines:

```
// [~/.shiftleft/policy/dynamic/java/io/ObjectInputStream.policy:]

IO deserializer = METHOD -f "java.io.ObjectInputStream.readObject:java.lang.Object()" { INST "SINK" }
```

This states that the instance parameter of the method `readObject` should be considered as a data sink of a deserializer, that is, the instance parameter is deserialized.

```
// ~/.shiftleft/policy/dynamic/org/springframework/exposed.policy:

TAG "DATA_TYPE" -v "attacker-controlled" METHOD -a r"org\.springframework\.web\.bind\.annotation\.(Request|Get|Post|Put|Delete|Patch)Mapping" PAR -a r"org\.springframework\.web\.bind\.annotation\.(CookieValue|PathVariable|RequestParam|RequestBody)"
```

This rule specifies that all parameters tagged with the Spring annotations "CookieValue", "PathVariable", and a few others are to be tagged as "attacker-controlled. Finally, we can specify that flows of attacker-controlled data into deserializers are worth reporting:

```
// ~/.shiftleft/policy/static/execute.policy:

CONCLUSION attacker-to-deserializer = FLOW DATA (attacker-controlled) -> IO (deserializer)
WHEN CONCLUSION attacker-to-deserializer => EMIT {
    title: "Attacker controlled data to deserialization",
    description: "Attacker controlled data is deserialized in this flow. ...",
    category: "a1-injection",
    score: "8.0"
}
```

The policy language additionally allows data transformations and checks to be specified in order to report flows of data, only if data does not undergo validation. For a detailed description of the query language, please see [Policy language](policy.md).

# Extending the DSL via the "Pimp my library" pattern

The domain specific language can be enhanced by the user via the "Pimp my library pattern". For example, in the following script, a method named `whatICareAbout` is added to findings, which can subsequently be evaluated on findings just like built in language elements:

```scala
import io.shiftleft.libsecurityprofile.steps.SpFinding

class MyMethods(findings : SpFinding) {
    <b>def whatICareAbout = findings.filter(x => x.score >= 8 && x.categories.contains("a1-injection"))</b>
}

implicit def conv(findings: SpFinding) = new MyMethods(findings)

@main def exec(spFilename: String, outFilename: String) = {
    loadSp(spFilename)
    sp.findings.whatICareAbout.l |> outFilename
}
```
